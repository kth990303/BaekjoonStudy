<!DOCTYPE html>
<html>
    <head>
        <title>이번주 문제 힌트</title>
        <meta charset="utf-8">
        <style>
            body{
                background-color:black;
                font-family:Arial, Helvetica, sans-serif;
                margin: 0px;
                color: rgba(255, 255, 255, 0.534);
            }
            header{
                background-color: #634c68;
                color:#000000;
                margin: 0px;
                text-align: center;
                padding: 15px;
            }
            header p{
                position:absolute;
                top:2px;
                left:15px;
            }
            h1{
                margin: 0px;
            }
            section#main{
                display: table-cell;
                width: 80%;
                background-color: black;
                padding: 15px;
            }
            nav{
                display: table-cell;
                width: 20%;
                background-color: rgba(112, 128, 144, 0.822);
                padding: 15px;
            }
            footer{
                background-color: #954b4b;
                color:#efe5d0;
                text-align: center;
                padding: 10px;
                margin: 0px 0px 0px 0px;
                font-size: 90%;
            }
            a:link{
                text-decoration: underline;
                color:rgb(111, 111, 255);
            }
            a:visited{
                text-decoration: underline;
                color:rgb(194, 86, 194);
            }
        </style>
    </head>
    <body>
        <header>
            <h1>이번 주 문제들 힌트!</h1>
            <p><a href="https://kth990303.github.io/BaekjoonStudy/test/solvedInfo.html">HOME</a></p>
        </header>
        <nav>
            <h1>Links</h1>
            <ul>
                <li><a href="https://solved.ac/profile/kth990303">kth990303 프로필</a></li>
                <li><a href="https://solved.ac/profile/hiha">hiha 프로필</a></li>
                <li><a href="https://solved.ac/profile/2sms22rjt">2sms22rjt 프로필</a></li>
            </ul>
        </nav>
        <section id="main">
            <article>
                <h1>
                    hiha님 문제
                </h1>
                <ol>
                    <li>
                        직사각형에서 탈출: 
                    </li><br>
                    <li>
                        주사위: 
                    </li><br>
                    <li>
                        좋은 놈 나쁜 놈: 
                    </li><br>
                    <li>
                        팰린드롬 수: 나머지끼리 비교해도 상관은 없으나, 문자열로 만들어서 비교하면
                        편하지 않을까? C++에서 숫자를 문자열로 바꾸려면 to_string함수를 쓰면된다.
                        예를 들어 N=123 이면, to_string(N)으로 해서 문자열로 바꾼 후, 
                        문자열 s의 s.length()/2까지 서로 문자가 일치하면 팰린드롬이라고 하면 되겠다.
                    </li><br>
                    <li>
                        덩치: 각각의 등수를 담는 배열을 만들어주고, 서로의 몸무게와 키를 비교시켜서
                        둘 다 크다 싶으면 등수를 높혀주자. N의 범위가 작으니 노가다시켜주면 될듯?
                    </li><br>
                    <li>
                        이건 꼭 풀어야 해!: 피드백 때 배운 '누적 합 알고리즘'을 그대로 이용하는 문제.
                        어렵다면, prefix_sum algorithm을 다시 복습하자. 참고로, 합의 배열에서 
                        뺄 때, 구하려는 값까지 빼지 않도록 주의하자.
                    </li><br>
                    <li>
                        기상청 인턴 신현수: 만약 맞왜틀 중이라면 3 2 -3 -2 -1 을 예제로 집어넣어보자.
                        유의 포인트는 두 가지. 첫째로, 정말로 끝까지 탐색하는가? 둘째로, 음수일 때도
                        고려했는가? 이 문제는, N 범위가 너무 작아서 O(N^2)인 브루트포스 알고리즘으로도
                        충분히 해결 가능하나, 누적합으로도 연습해보았음 좋겠어서 넣었습니다.
                        누적합 기준 난이도는 Silver III 입니다.
                    </li><br>
                    <li>
                        악수: dp를 푸는 방법은 두 가지가 있다. 탑다운 방식, 바텀업 방식.
                        둘 다 재귀를 이용하는 방법이지만, 탑다운 방식은 재귀, 바텀업 방식은 for문으로
                        반복문을 이용해서 해결한다. 보통은 점화식을 찾으면 for문으로 점화식을 돌리고,
                        브루트포스로 재귀를 이용하는 대신 조건을 걸고 메모이제이션을 이용할 수 있겠다
                        싶으면 탑다운 방식을 이용한다. 이 문제같은 경우는 점화식을 찾기가 쉬운 편이다.
                        첫번째로, 그냥 n이 1일 때, 2일 때, 3일 때 쭉 나열해보면 나오지 않을까?
                        아니라면 다른 방법으론, n이 k일 때, k-1명 경우 + k-2명 경우의 수, k-3명 
                        경우 + k-1명 경우, 이런 식으로 점화식을 세울 수 있지 않을까 생각해보자. 
                        다행히, 문제에 그림을 보면 쉽게(사실 쉽지는 않다) 파악이 가능하다.
                        이 문제는 Silver V ~ Silver IV에 적합한 dp이다.  
                    </li><br>
                    <li>
                        수리공 항승: 그리디에서 가져온 문제인데, 그닥 그리디적인 면은 많이 없다.
                        일단 sort해주고, 물이 새는 곳 a, b가 L미만으로 떨어져있으면 같은 테이프로
                        붙일 수 있다. 예를 들어 N=7, L=2, 1 2 3 5 6 100 101이면, 0.5~2.5, 2.5~3.5,
                        4.5~6.5, 99.5~101.5 이렇게 총 4개가 된다. (뜬금없이 테케를 하나 더 줘버렸다)
                        딱히 그리디라 할만한 건 없고, 정렬을 잘하고 구현 잘하면 될 것 같다.
                        반복문을 이용해서 두 사이 지점이 L 미만이면 조금 더 먼 거리의 지점까지 이어붙이
                        도록 시도해보고, L 이상이 되면, 이 곳은 테이프로 붙이면 된다. 이 경우를 N까지
                        반복해주면 된다. 참고로 저는 투포인터로 풀었습니다...
                    </li><br>
                </ol>
            </article>
            <article>
                <h1>2sms22rjt님 문제</h1>
                <ol>
                    <li>
                        예산: 사실상 피드백 때 했던 '나무 자르기'랑 유사한 문제. 이분 탐색에서 최소, 최대는
                        과연 언제가 좋을까? M의 범위가 N 이상이니까 딱 N일 때를 가정해보자. 이분 탐색은
                        극단적으로 큰 값, 작은값으로 진행되니까 이 극단값일 때를 대입해서 파악해보면 좋다.
                        나무 자르기랑 유사하게 하면 큰 문제는 없을 듯
                    </li><br>
                    <li>
                        영역 구하기: 또 다시 그래프 탐색 문제이다. 이 문제 같은 경우는 지난주 과제처럼 컴포넌트(영역)
                        개수를 세주면 되는 문제. 다만, 이번엔 점의 좌표가 주어지는게 성가시다. 필자는 점의 좌표를
                        모눈 단위로 바꿔서 문제를 풀었다. 그렇게 하면 다른 bfs, dfs문제와 유사하게 컴포넌트 개수를
                        구하면 되는 문제. dfs, bfs 모두 가능하며, N과 M이 최대 100이므로, 시간 초과를 겪을 걱정은
                        딱히 없겠다. 점의 좌표가 주어져서 헷갈리다면, 그림을 직접 그리면서 해결해보자. 잘 보면 배열의
                        인덱스는 0부터 시작한다는 점때문에 어떤 때는 오른쪽 위의 좌표가 포함되지 않고, 어떤 때는 
                        왼쪽 아래의 좌표가 포함되지 않을 것이다.
                    </li><br>
                    <li>
                        안녕: 그리디로 접근할까 dp로 접근할까 브루트포스로 접근할까 그래프로 접근할까. 
                        사실 이 문제는 N의 범위가 너무 작아서(20) 어떤 수를 쓰든간에 다 풀린다. 그렇지만 아무래도
                        어떤 경우를 선택하는지에 따라 다음 경우 또한 달라지니까 dp가 생각나지 않을까. Silver II라
                        적혀 있지만, 사실상 dp로 풀면 Silver I으로 올라가도 될만한 문제. knapsack 유형이라고
                        유명한 유형 중 하나인데, 그 유형의 하위 호환이라 보면 될듯. 이 문제는 현재꺼를 선택할지,
                        선택하지 않을지에 따라 경우가 나뉜다. 그리고, 체력에 따라서도 갈리니까 dp로 푼다면
                        몇 번째인지, 체력이 어느정도인지 이렇게 이차원 배열로 잡아주어야 한다. 그렇지 않으면
                        체력에 따른 메모이제이션이 없어 제대로 된 값을 메모이제이션하지 못할 수도?
                        개인적으론 탑다운 방식이 더 편해보인다.
                    </li><br>
                    <li>
                        수리공 항승: 그리디에서 가져온 문제인데, 그닥 그리디적인 면은 많이 없다.
                        일단 sort해주고, 물이 새는 곳 a, b가 L미만으로 떨어져있으면 같은 테이프로
                        붙일 수 있다. 예를 들어 N=7, L=2, 1 2 3 5 6 100 101이면, 0.5~2.5, 2.5~3.5,
                        4.5~6.5, 99.5~101.5 이렇게 총 4개가 된다. (뜬금없이 테케를 하나 더 줘버렸다)
                        딱히 그리디라 할만한 건 없고, 정렬을 잘하고 구현 잘하면 될 것 같다. 참고로
                        저는 투포인터로 풀었습니다...
                    </li><br>
                    <li>
                        랜선 자르기: 이분 탐색을 까먹었다면 다시 복습하자. 다만, 만약 58%에서 맞왜틀을
                        하고 있다면 s, e 범위가 2^31-1이므로 이분 탐색 중에 s가 커지는 경우를 상상해보자.
                        만약 82%에서 런타임 에러를 겪고 있다면 mid가 0이 될 때를 생각해보자. s=0, e=1일
                        때 분명히 런타임 에러가 발생할 것이다. 그 경우가 아니더라도, 런타임 에러가 발생할 
                        수 있다. (모두 kth990303이 똑같이 겪은 현상...)
                    </li><br>
                    <li>
                        가장 긴 증가하는 부분수열: 굉장히 유명한 문제. LIS 알고리즘. 하지만, 많이 어려울 것.
                        Silver I으로 가도 괜찮을 정도이다. 개인적으론 바텀업 방법이 조금 더 쉬운듯.
                        참고로, 항상 맨처음부터 시작하는 경우가 LIS 답이 아닐 수 있다.
                        바텀업 방법으로는 for문을 두 번 써서 for(i=0; ... ) 안에 for(j=i+1 ...) 이렇게 한 후
                        j번째 원소가 i번째 원소보다 클 경우, 더 길게 하는 경우를 대입하게 해주면 된다.
                        탑다운 방법으로는 자기 자신이 길이가 1임을 기억하고, for문으로 현재 자신의 원소 번째보다
                        이후 원소들을 비교해서 더 큰 원소가 있다면, 그 원소 기준으로 재귀를 돌아주면 됨.
                    </li><br>
                </ol>
            </article>
        </section>
        <footer>Copyright (c) 2020, kth990303의 백준 스터디</footer>
    </body>
</html>