<!DOCTYPE html>
<html>
    <head>
        <title>이번주 문제 힌트</title>
        <meta charset="utf-8">
        <style>
            body{
                background-color:black;
                font-family:Arial, Helvetica, sans-serif;
                margin: 0px;
                color: rgba(255, 255, 255, 0.534);
            }
            header{
                background-color: #634c68;
                color:#000000;
                margin: 0px;
                text-align: center;
                padding: 15px;
            }
            header p{
                position:absolute;
                top:2px;
                left:15px;
            }
            h1{
                margin: 0px;
            }
            section#main{
                display: table-cell;
                width: 80%;
                background-color: black;
                padding: 15px;
            }
            nav{
                display: table-cell;
                width: 20%;
                background-color: rgba(112, 128, 144, 0.822);
                padding: 15px;
            }
            footer{
                background-color: #954b4b;
                color:#efe5d0;
                text-align: center;
                padding: 10px;
                margin: 0px 0px 0px 0px;
                font-size: 90%;
            }
            a:link{
                text-decoration: underline;
                color:rgb(111, 111, 255);
            }
            a:visited{
                text-decoration: underline;
                color:rgb(194, 86, 194);
            }
        </style>
    </head>
    <body>
        <header>
            <h1>이번 주 문제들 힌트!</h1>
            <p><a href="https://kth990303.github.io/BaekjoonStudy/test/solvedInfo.html">HOME</a></p>
        </header>
        <nav>
            <h1>Links</h1>
            <ul>
                <li><a href="https://solved.ac/profile/kth990303">kth990303 프로필</a></li>
                <li><a href="https://solved.ac/profile/hiha">hiha 프로필</a></li>
                <li><a href="https://solved.ac/profile/2sms22rjt">2sms22rjt 프로필</a></li>
            </ul>
        </nav>
        <section id="main">
            <article>
                <h1>
                    hiha님 문제
                </h1>
                <ol>
                    <li>
                        직사각형에서 탈출: 힌트 제공 없음.
                    </li><br>
                    <li>
                        주사위: s1<=20, s2<=20, s3<=40이라 전부 브루트포스로 돌아도 O(16000)이라
                        시간초과를 걱정할 필요가 전혀 없는 문제. 전부 브루트포스로 돌고, 각 합이 나온
                        개수의 배열에 저장시켜서, 가장 큰 값을 출력하자.
                    </li><br>
                    <li>
                        좋은 놈 나쁜 놈: 공백을 입력받으려면 getline(cin, str)를 써야 한다 (C++17 이상)
                        그리고 만약, N을 입력받아 맨처음에 엔터가 입력받아져 IS NEUTRAL가 출력된다면,
                        cin.ignore()로 cin 버퍼를 비워주면 된다. 단순히 문자열을 입력받으면 'g', 'G', 
                        'b', 'B' 개수를 세주는 문제. 대문자도 세야 함에 유의하자.
                    </li><br>
                    <li>
                        팰린드롬 수: 나머지끼리 비교해도 상관은 없으나, 문자열로 만들어서 비교하면
                        편하지 않을까? C++에서 숫자를 문자열로 바꾸려면 to_string함수를 쓰면된다.
                        예를 들어 N=123 이면, to_string(N)으로 해서 문자열로 바꾼 후, 
                        문자열 s의 s.length()/2까지 서로 문자가 일치하면 팰린드롬이라고 하면 되겠다.
                    </li><br>
                    <li>
                        덩치: 각각의 등수를 담는 배열을 만들어주고, 서로의 몸무게와 키를 비교시켜서
                        둘 다 크다 싶으면 등수를 높혀주자. N의 범위가 작으니 노가다시켜주면 될듯?
                    </li><br>
                    <li>
                        이건 꼭 풀어야 해!: 피드백 때 배운 '누적 합 알고리즘'을 그대로 이용하는 문제.
                        어렵다면, prefix_sum algorithm을 다시 복습하자. 참고로, 합의 배열에서 
                        뺄 때, 구하려는 값까지 빼지 않도록 주의하자.
                    </li><br>
                    <li>
                        기상청 인턴 신현수: 만약 맞왜틀 중이라면 3 2 -3 -2 -1 을 예제로 집어넣어보자.
                        유의 포인트는 두 가지. 첫째로, 정말로 끝까지 탐색하는가? 둘째로, 음수일 때도
                        고려했는가? 이 문제는, N 범위가 너무 작아서 O(N^2)인 브루트포스 알고리즘으로도
                        충분히 해결 가능하나, 누적합으로도 연습해보았음 좋겠어서 넣었습니다.
                        누적합 기준 난이도는 Silver III 입니다.
                    </li><br>
                    <li>
                        악수: dp를 푸는 방법은 두 가지가 있다. 탑다운 방식, 바텀업 방식.
                        둘 다 재귀를 이용하는 방법이지만, 탑다운 방식은 재귀, 바텀업 방식은 for문으로
                        반복문을 이용해서 해결한다. 보통은 점화식을 찾으면 for문으로 점화식을 돌리고,
                        브루트포스로 재귀를 이용하는 대신 조건을 걸고 메모이제이션을 이용할 수 있겠다
                        싶으면 탑다운 방식을 이용한다. 이 문제같은 경우는 점화식을 찾기가 쉬운 편이다.
                        첫번째로, 그냥 n이 1일 때, 2일 때, 3일 때 쭉 나열해보면 나오지 않을까?
                        아니라면 다른 방법으론, n이 k일 때, k-1명 경우 + k-2명 경우의 수, k-3명 
                        경우 + k-1명 경우, 이런 식으로 점화식을 세울 수 있지 않을까 생각해보자. 
                        다행히, 문제에 그림을 보면 쉽게(사실 쉽지는 않다) 파악이 가능하다.
                        이 문제는 Silver V ~ Silver IV에 적합한 dp이다.  
                    </li><br>
                    <li>
                        수리공 항승: 그리디에서 가져온 문제인데, 그닥 그리디적인 면은 많이 없다.
                        일단 sort해주고, 물이 새는 곳 a, b가 L미만으로 떨어져있으면 같은 테이프로
                        붙일 수 있다. 예를 들어 N=7, L=2, 1 2 3 5 6 100 101이면, 0.5~2.5, 2.5~3.5,
                        4.5~6.5, 99.5~101.5 이렇게 총 4개가 된다. (뜬금없이 테케를 하나 더 줘버렸다)
                        딱히 그리디라 할만한 건 없고, 정렬을 잘하고 구현 잘하면 될 것 같다.
                        반복문을 이용해서 두 사이 지점이 L 미만이면 조금 더 먼 거리의 지점까지 이어붙이
                        도록 시도해보고, L 이상이 되면, 이 곳은 테이프로 붙이면 된다. 이 경우를 N까지
                        반복해주면 된다. 참고로 저는 투포인터로 풀었습니다...
                    </li><br>
                </ol>
            </article>
            <article>
                <h1>2sms22rjt님 문제</h1>
                <ol>
                    <li>
                        트리의 부모 찾기: 보통의 dfs, bfs와 같으나, 보통 자식을 출력하는 경우가 많은데,
                        부모를 출력하라니 조금 까다로울 수도 있다. 보통 이런 경우는 부모 배열을 저장해놓고
                        어떤 노드를 탐색할 때 그 노드의 부모를 부모배열에 저장시킨 후, 
                        탐색이 끝난 후 그 부모배열을 출력해준다.
                    </li><br>
                    <li>
                        N과 M(6): 오름차순은 N과 M(2)에서, 그리고 특정 수만 뽑아내는 건 N과 M(5)에서
                        봤다. 특정 수를 따로 배열에 저장시키든지 해서, 백트래킹으로 뽑아내자.
                    </li><br>
                    <li>
                        어두운 건 무서워: 힌트 제공 없음.
                    </li><br>
                    <li>
                        풍선 맞추기: 힌트 제공자가 아직 풀지 않음.
                    </li><br>
                    <li>
                        LCS: 공통부분 문자열. 보통은 탑다운이나 바텀업이나 풀이 난이도가 비슷한데,
                        이 경우는 바텀업이 훨씬 쉽다. dp로 해결할 수 있어보이는건 당연하고, 
                        이전 공통 부분 문자열 길이에서 또 공통된다면 +1 해주면 되는데,
                        힌트 쓰기가 귀찮으니 나중에 추가하겠다.
                    </li><br>
                    <li>
                        공유기 설치: 힌트 제공 없음.
                    </li><br>
                    <li>
                        전깃줄: 도대체 어떻게 해야 꼬인 전깃줄의 개수를 구할 수 있을까?
                        반대로 생각해보면, 어떤 전깃줄만 있어야 최대한 꼬이지 않게 연결해줄 수 있을까?
                        이렇게 하면 가장 긴 증가하는 부분수열로 연결지을 수 있을 거 같다. 
                        전깃줄 N개에서 가장 긴 증가하는 부분수열의 개수를 빼주면 될 것 같다.
                        N이랑 위치번호도 500 이하니까 N^2을 돌든 N^3을 돌든 큰 상관도 없다. 
                        만약 런타임에러가 뜬다면, 전깃줄 위치번호는 500까지 있음을 명심하자.
                    </li>
                </ol>
            </article>
        </section>
        <footer>Copyright (c) 2021, kth990303의 백준 스터디</footer>
    </body>
</html>