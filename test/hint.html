<!DOCTYPE html>
<html>
    <head>
        <title>이번주 문제 힌트</title>
        <meta charset="utf-8">
        <style>
            body{
                background-color:black;
                font-family:Arial, Helvetica, sans-serif;
                margin: 0px;
                color: rgba(255, 255, 255, 0.534);
            }
            header{
                background-color: #634c68;
                color:#000000;
                margin: 0px;
                text-align: center;
                padding: 15px;
            }
            header p{
                position:absolute;
                top:2px;
                left:15px;
            }
            h1{
                margin: 0px;
            }
            section#main{
                display: table-cell;
                width: 80%;
                background-color: black;
                padding: 15px;
            }
            nav{
                display: table-cell;
                width: 20%;
                background-color: rgba(112, 128, 144, 0.822);
                padding: 15px;
            }
            footer{
                background-color: #954b4b;
                color:#efe5d0;
                text-align: center;
                padding: 10px;
                margin: 0px 0px 0px 0px;
                font-size: 90%;
            }
            a:link{
                text-decoration: underline;
                color:rgb(111, 111, 255);
            }
            a:visited{
                text-decoration: underline;
                color:rgb(194, 86, 194);
            }
        </style>
    </head>
    <body>
        <header>
            <h1>이번 주 문제들 힌트!</h1>
            <p><a href="https://kth990303.github.io/BaekjoonStudy/test/solvedInfo.html">HOME</a></p>
        </header>
        <nav>
            <h1>Links</h1>
            <ul>
                <li><a href="https://solved.ac/profile/kth990303">kth990303 프로필</a></li>
                <li><a href="https://solved.ac/profile/hiha">hiha 프로필</a></li>
                <li><a href="https://solved.ac/profile/2sms22rjt">2sms22rjt 프로필</a></li>
            </ul>
        </nav>
        <section id="main">
            <article>
                <h1>
                    hiha님 문제
                </h1>
                <ol>
                    <li>
                        캠핑: P일 중 L일을 최대한 다 사용해보자. 굳이 L일에 해당되지 않는 요일에
                        캠핑을 갈 필요가 있을까...?
                    </li><br>
                    <li>
                        피보나치는 지겨웡~: 전형적인 dp문제. 다만, 다른 문제들과는 다르게 피보나치 함수가
                        호출되는 횟수를 묻는 문제이다. 피보나치 함수는 d[i]=d[i-1]+d[i-2];의 식을 따르고,
                        거기에 자기 자신이 호출되므로, 위 함수에서 1을 추가해주면 d[i]가 된다. 자료형이
                        long long이 될 수 있음에 주의한다.
                    </li><br>
                    <li>
                        덩치: 각각의 등수를 담는 배열을 만들어주고, 서로의 몸무게와 키를 비교시켜서
                        둘 다 크다 싶으면 등수를 높혀주자. N의 범위가 작으니 노가다시켜주면 될듯?
                    </li><br>
                    <li>
                        피자 (Small): dp, 수학 모두 가능. 다만, 답을 나열하면 너무 쉬워지는 문제...
                        증명은 수학적 귀납법으로 가능한데, 증명이 좀 까다롭다.
                    </li><br>
                    <li>
                       N과 M (4): 중복조합 문제이다. N과 M (2)와 (3)의 짬뽕 문제.
                       같은 수를 여러번 골라도 되면 visit 변수가 필요없을 수도 있겠다.
                       비내림차순은 for문으로 적절히 잘 구현하면 가능할 것 같다.
                    </li><br>
                    <li>
                        카드 합체 놀이: 이 문제를 제대로 풀었다고 확신한다면 M을 키워서 한번 아무 반례를
                        만들어서 대입해보자. 수가 엄청나게 커지는 것을 확인할 수 있을 것이다.
                        이 문제의 경우 사실 priority_queue를 이용하면 쉽게 구현할 수 있다.
                        그리디적인 면으로는 작은 수끼리 m번 더하면 되므로 Silver V급으로 쉬우나, 
                        구현이 조금 까다로워서 Silver III가 된 듯한 문제. priority_queue를 모른다면
                        벡터에 넣고 sorting 후, 작은 수 두개를 더한 수로 바꿔주고, 다시 sorting하고를
                        반복해주면 된다.
                    </li><br>
                </ol>
            </article>
            <article>
                <h1>2sms22rjt님 문제</h1>
                <ol>
                    <li>
                        촌수 계산: bfs든 dfs든 가능한 문제. 자신에게 연결된 간선 중 visit하지 않은 간선으로
                        다음 촌수로 넘어갈 때마다 그 값을 +해주면서, 찾는 촌수가 나왔으면 리턴해주면 되지 않을까?
                    </li><br>
                    <li>
                        연결 요소의 개수: bfs, dfs, 심지어 컴포넌트 개수를 세는 문제이므로 유니온파인드까지도
                        가능한 문제. 단순히 탐색을 해주고, 이제 더 이상 돌릴게 없으면 탐색을 끝내준다.
                        어떻게 보면 브루트포스라고도 볼 수가 있겠네.
                    </li><br>
                    <li>
                        미로 탐색: 왜 DFS가 안되는지 파악되시죠? ㅋㅋㅋ BFS 범위 체크 잘해야됩니다.
                        이 문제 같은 경우는 너무 어려우면 이거 참고하세요.
                        <a href="https://www.acmicpc.net/source/share/372c7489c77a4088b308d56a63b2fb7a"
                        target="_blank">소스 코드 보기</a> 맨 첫번째 칸부터 상하좌우로 탐색을 시작하면서
                        1이면 큐에 집어넣기. 만약 이동할 수 있는 칸이 없으면 따로 구현을 해야 하는가??
                        그리고 이 문제같은 경우, 예제 입력2에서 막힐 수 있다. 이 경우, 각 칸마다 최소
                        몇 칸 이동해야 여기로 올 수 있는지 저장해주게 구현해주면 되지 않을까? 트리+dp,
                        그래프+dp의 기본이라 볼 수 있는 문제이다. 맞왜틀인 경우, 확실하게 상하좌우로
                        이동하는지, 범위 체크를 잘했는지, 방문여부 체크를 잘했는지 다시 한 번 확인해보자.
                    </li><br>
                    <li>
                        안전 영역: dfs, bfs 모두 풀 수 있는 문제. 조금 어려운 문제다. 구현도 조금 필요하고.
                        이미 물에 젖었으면 그건 쳐다볼 필요도 없는 칸. 잘 생각해보면 이거는 11724번 문제랑
                        상당히 유사하다. 심지어 11724번은 Silver II... 대신, 단순 양방향 그래프가 아닌,
                        상하좌우로 탐색하면서 컴포넌트 개수를 세주어야 하는 문제~
                    </li><br>
                    <li>
                        말이 되고픈 원숭이: 좀 어려운 bfs문제. 일단 이 말이 되고픈 원숭이놈이 이동방향이
                        우리가 평소에 보던 상하좌우 방향으로도 움직이는데 또 이상한 방향으로도 움직인다.
                        여기서 1차적으로 어려움을 느낄 것이고, 말의 움직임으로 이동하는 횟수에 심지어
                        제한까지 걸려있다. 이 원숭이는 도대체 왜 이런 헛운동을 하는 것일까... 이런 유형의
                        문제를 풀어보지 않았다면 더더욱 어려울 것이다. Gold IV까지도 갈 수 있다고 보는 문제.
                        심지어 풀었다 해도 시간초과를 겪기 아주 쉬운 문제이다. 이 문제는 방문했던 곳을
                        다시 방문하면 안된다는 제한도 없을 뿐더러, 방향이 겁나 이상하기 때문에, 이미 방문
                        했던 곳을 방문한 후, 말의 방향으로 이동하는 경우가 오히려 빠른 경우가 존재한다.
                        그렇다고 visit변수를 없애면 bfs 성격상 바로 시간초과~ 즉, 방문 여부 체크변수를 
                        그대로 두되, 현재 몇 번 이동했는지도 방문 여부 체크변수에 영향을 준다 이거다~
                        그리고 몇 번 이동했는지 다음 탐색을 할 때도 알아야 되니까, 
                        전역변수로 지정해주든, 큐에 인자를 좌표 외에도 추가로 이거까지 전해주든 상관없다.
                    </li><br>
                </ol>
            </article>
        </section>
        <footer>Copyright (c) 2020, kth990303의 백준 스터디</footer>
    </body>
</html>